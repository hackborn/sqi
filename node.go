package sqi

import (
	"strconv"
	"strings"
)

// ------------------------------------------------------------
// NODE-T

func newNode(s symbol, text string) *node_t {
	token, ok := token_map[s]
	if !ok {
		token = token_map[illegal_token]
	}
	return &node_t{Token: token, Text: text}
}

// node_t serves two purposes: it is a token generated by the
// lexer, and it is a node in the tree constructed by the parser.
type node_t struct {
	// Lexing
	Token *token_t
	Text  string

	// Parsing
	Parent *node_t `json:"-"`
	// XXX Note: This has stayed here because I really want to
	// remove the overhead of allocating a slice while building
	// the tree. For the whole time, no nodes can have more than
	// two children and I've been able to do that, but I suspect
	// future functions will require a child list.
	//	Left     *node_t
	//	Right    *node_t
	Children []*node_t `json:"omitempty"`
}

// reclassify() converts this token into one of the defined
// keywords, if appropriate. Ideally this is done directly
// in the scanning stage, but I'm not sure how to get the
// scanner to do that.
func (n *node_t) reclassify() *node_t {
	if n.Token.Symbol != string_token {
		return n
	}
	if found, ok := keyword_map[n.Text]; ok {
		return newNode(found.Symbol, n.Text)
	}
	return n
}

func (n *node_t) addChild(child *node_t) {
	n.Children = append(n.Children, child)
	child.Parent = n
}

// asAst() returns the AST node for this tree node.
func (n *node_t) asAst() (AstNode, error) {
	// fmt.Println("ast", n.Text)
	switch n.Token.Symbol {
	case eql_token, neq_token, and_token, or_token:
		lhs, rhs, err := n.makeBinary()
		if err != nil {
			return nil, err
		}
		return &binaryNode{Op: n.Token.Symbol, Lhs: lhs, Rhs: rhs}, nil
	case condition_token:
		child, err := n.makeUnary()
		if err != nil {
			return nil, err
		}
		return &conditionNode{Op: open_token, Child: child}, nil
	case float_token:
		if len(n.Children) != 0 {
			return nil, newParseError("float has wrong number of children: " + strconv.Itoa(len(n.Children)))
		}
		f64, err := strconv.ParseFloat(n.Text, 64)
		if err != nil {
			return nil, err
		}
		return &constantNode{Value: f64}, nil
	case int_token:
		if len(n.Children) != 0 {
			return nil, newParseError("int has wrong number of children: " + strconv.Itoa(len(n.Children)))
		}
		i, err := strconv.ParseInt(n.Text, 10, 32)
		if err != nil {
			return nil, err
		}
		return &constantNode{Value: int(i)}, nil
	case open_token:
		child, err := n.makeUnary()
		if err != nil {
			return nil, err
		}
		return &unaryNode{Op: open_token, Child: child}, nil
	case open_array:
		return n.makeArray()
	case path_token:
		return n.makePath()
	case string_token:
		if len(n.Children) != 0 {
			return nil, newParseError("string has wrong number of children: " + strconv.Itoa(len(n.Children)))
		}
		// Unwrap quoted text, which has served its purpose of allowing special characters.
		text := strings.Trim(n.Text, `"`)
		return &constantNode{Value: text}, nil
	}
	return nil, newParseError("on unknown token: " + strconv.Itoa(int(n.Token.Symbol)) + ", " + n.Token.Text)
}

func (n *node_t) makeBinary() (AstNode, AstNode, error) {
	if len(n.Children) != 2 {
		return nil, nil, newParseError("binary has wrong number of children: " + strconv.Itoa(len(n.Children)))
	}
	lhs, err := n.Children[0].asAst()
	if err != nil {
		return nil, nil, err
	}
	rhs, err := n.Children[1].asAst()
	if err != nil {
		return nil, nil, err
	}
	return lhs, rhs, nil
}

func (n *node_t) makeUnary() (AstNode, error) {
	if len(n.Children) != 1 {
		return nil, newParseError("unary has wrong number of children: " + strconv.Itoa(len(n.Children)))
	}
	return n.Children[0].asAst()
}

func (n *node_t) makeArray() (AstNode, error) {
	// A single child is a special case -- it indicates we're at the top of the tree,
	// and we'll operate on whatever input I receive, instead of processing a lhs.
	var lhs AstNode
	var childidx int
	var err error

	switch len(n.Children) {
	case 1:
		childidx = 0
	case 2:
		lhs, err = n.Children[0].asAst()
		if err != nil {
			return nil, err
		}
		childidx = 1
	default:
		return nil, newParseError("array has wrong number of children: " + strconv.Itoa(len(n.Children)))
	}

	params, err := n.makeArrayParams(childidx)
	if err != nil {
		return nil, err
	}
	return &arrayNode{Lhs: lhs, Index: params}, nil
}

// makeArrayParams() constructs the run params for an array node.
func (n *node_t) makeArrayParams(childidx int) (int, error) {
	if childidx < 0 || childidx >= len(n.Children) {
		return 0, newParseError("array has missing child at " + strconv.Itoa(childidx))
	}
	child := n.Children[childidx]
	if child.Token.Symbol != int_token {
		return 0, newParseError("array must have int")
	}
	index, err := strconv.ParseInt(child.Text, 0, 32)
	if err != nil {
		return 0, err
	}
	return int(index), nil
}

func (n *node_t) makePath() (AstNode, error) {
	// A path can have one or two children. If there are two, the first
	// must be a path and the second must be a string. If there is
	// one, the first must be a string.
	switch len(n.Children) {
	case 1:
		child0 := n.Children[0]
		// Parentheses can stack multiple paths. Consume them.
		for child0.Token.Symbol == path_token && len(child0.Children) == 1 {
			child0 = child0.Children[0]
		}
		// Validate
		if child0.Token.Symbol != string_token {
			return nil, newParseError("path must have string instead of " + child0.Token.Text)
		}
		text := strings.Trim(child0.Text, `"`)
		return &pathNode{Field: &fieldNode{Field: text}}, nil
	case 2:
		child0 := n.Children[0]
		child1 := n.Children[1]
		// Parentheses can stack multiple paths. Consume them.
		for child1.Token.Symbol == path_token && len(child1.Children) == 1 {
			child1 = child1.Children[0]
		}
		// Validate
		if child1.Token.Symbol != string_token {
			return nil, newParseError("path must end with a string")
		}
		cn, err := child0.asAst()
		if err != nil {
			return nil, err
		}
		text := strings.Trim(child1.Text, `"`)
		return &pathNode{Child: cn, Field: &fieldNode{Field: text}}, nil
	default:
		return nil, newParseError("path has wrong number of children: " + strconv.Itoa(len(n.Children)))
	}
}
