package sqi

import (
	"strconv"
	"strings"
)

// ------------------------------------------------------------
// NODE-T

func newNode(s symbol, text string) *node_t {
	token, ok := token_map[s]
	if !ok {
		token = token_map[illegal_token]
	}
	return &node_t{Token: token, Text: text}
}

// node_t serves two purposes: it is a token generated by the
// lexer, and it is a node in the tree constructed by the parser.
type node_t struct {
	// Lexing
	Token *token_t
	Text  string

	// Parsing
	Parent *node_t `json:"-"`
	// XXX Note: This has stayed here because I really want to
	// remove the overhead of allocating a slice while building
	// the tree. For the whole time, no nodes can have more than
	// two children and I've been able to do that, but I suspect
	// future functions will require a child list.
	//	Left     *node_t
	//	Right    *node_t
	Children []*node_t
}

// reclassify() converts this token into one of the defined
// keywords, if appropriate. Ideally this is done directly
// in the scanning stage, but I'm not sure how to get the
// scanner to do that.
func (n *node_t) reclassify() *node_t {
	if n.Token.Symbol != string_token {
		return n
	}
	if found, ok := keyword_map[n.Text]; ok {
		return newNode(found.Symbol, n.Text)
	}
	return n
}

func (n *node_t) addChild(child *node_t) {
	n.Children = append(n.Children, child)
	child.Parent = n
}

// asAst() returns the AST node for this tree node.
func (n *node_t) asAst() (AstNode, error) {
	//	fmt.Println("ast", n.Text)
	switch n.Token.Symbol {
	case eql_token, neq_token, and_token, or_token:
		lhs, rhs, err := n.makeBinary()
		if err != nil {
			return nil, err
		}
		return &binaryNode{Op: n.Token.Symbol, Lhs: lhs, Rhs: rhs}, nil
	case condition_token:
		child, err := n.makeUnary()
		if err != nil {
			return nil, err
		}
		return &conditionNode{Op: open_token, Child: child}, nil
	case float_token:
		if len(n.Children) != 0 {
			return nil, newParseError("float has wrong number of children: " + strconv.Itoa(len(n.Children)))
		}
		f64, err := strconv.ParseFloat(n.Text, 64)
		if err != nil {
			return nil, err
		}
		return &constantNode{Value: f64}, nil
	case int_token:
		if len(n.Children) != 0 {
			return nil, newParseError("int has wrong number of children: " + strconv.Itoa(len(n.Children)))
		}
		i, err := strconv.ParseInt(n.Text, 10, 32)
		if err != nil {
			return nil, err
		}
		return &constantNode{Value: int(i)}, nil
	case open_token:
		child, err := n.makeUnary()
		if err != nil {
			return nil, err
		}
		return &unaryNode{Op: open_token, Child: child}, nil
	case path_token:
		return n.makePath()
	case string_token:
		if len(n.Children) != 0 {
			return nil, newParseError("string has wrong number of children: " + strconv.Itoa(len(n.Children)))
		}
		// Unwrap quoted text, which has served its purpose of allowing special characters.
		text := strings.Trim(n.Text, `"`)
		return &constantNode{Value: text}, nil
	}
	return nil, newParseError("on unknown token: " + strconv.Itoa(int(n.Token.Symbol)))
}

func (n *node_t) makeBinary() (AstNode, AstNode, error) {
	if len(n.Children) != 2 {
		return nil, nil, newParseError("binary has wrong number of children: " + strconv.Itoa(len(n.Children)))
	}
	lhs, err := n.Children[0].asAst()
	if err != nil {
		return nil, nil, err
	}
	rhs, err := n.Children[1].asAst()
	if err != nil {
		return nil, nil, err
	}
	return lhs, rhs, nil
}

func (n *node_t) makeUnary() (AstNode, error) {
	if len(n.Children) != 1 {
		return nil, newParseError("unary has wrong number of children: " + strconv.Itoa(len(n.Children)))
	}
	return n.Children[0].asAst()
}

func (n *node_t) makePath() (AstNode, error) {
	// A path can have one or two children. If there are two, the first
	// must be a path and the second must be a string. If there is
	// one, the first must be a string.
	switch len(n.Children) {
	case 1:
		child0 := n.Children[0]
		// Validate
		if child0.Token.Symbol != string_token {
			return nil, newParseError("path must have string")
		}
		text := strings.Trim(child0.Text, `"`)
		return &pathNode{Field: &fieldNode{Field: text}}, nil
	case 2:
		child0 := n.Children[0]
		child1 := n.Children[1]
		// Validate
		if child0.Token.Symbol != path_token || child1.Token.Symbol != string_token {
			return nil, newParseError("path must have path and string")
		}
		cn, err := child0.asAst()
		if err != nil {
			return nil, err
		}
		text := strings.Trim(child1.Text, `"`)
		return &pathNode{Child: cn, Field: &fieldNode{Field: text}}, nil
	default:
		return nil, newParseError("path has wrong number of children: " + strconv.Itoa(len(n.Children)))
	}
}
